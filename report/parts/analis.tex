\chapter{Аналитическая часть}

В данной часте будут рассмотрены объекты сцены, модели их представления, способы задания и способы хранения. Также будут описаны алгоритмы 
удаления невидимых линий и алгоритмы построения теней.

\section{Описание объектов сцены}

\textbf{Площадка сцены} –- правильный параллелепипед с заданной сеткой, по которой
расставляются модели. Объекты располагаются только на одной из сторон площадки. Границы
задаются количеством ячеек (квадратов) по длине и ширине. Размер ячеек -– константная величина,
определяемая внутри программы. Пользователь может использовать камеру для движения по сцене.

\textbf{Объекты сцены} –- модели, расположенные на площадке сцены, которые занимают
определенное количество клеток сетки (ячеек). Каждая модель представляет собой набор граней,
описываемых точками в пространстве, которые соединены ребрами. Все модели определены
заранее, в программе не предусмотрена возможность добавления новых или изменения старых
моделей. В программном обеспечении доступно изменение положения, добавление или удаление объектов на сцене.

\section{Выбор модели представления объектов}

Отображением формы и размеров объектов являются модели. Они могут быть следующих видов:
\begin{enumerate}
    \item \textit{\textbf{Каркасная модель}}. Одна из простейших форм задания модели, так как мы храним информацию
    только о вершинах и ребрах нашего объекта. Основная проблема отображения объекта с помощью
    данной модели заключается в том, что модель не всегда однозначно может передать представление
    о форме объекта;
    \item \textit{\textbf{Поверхностная модель}}. Такая информационная модель содержит данные только о внешних
    геометрических параметрах объекта. Данный тип модели часто используется в компьютерной
    графике. При этом могут использоваться различные типы поверхностей, ограничивающих объект,
    такие как полигональные модели, поверхности второго порядка и др. Недостатком данной модели
    является отсутствие информации о том, с какой стороны поверхности находится материал;
    \item \textit{\textbf{Объемная модель}}. Данная форма задания модели отличается от поверхностной наличием
    информации о том, с какой стороны расположен материал. Это реализуется с помощью указания
    направления внутренней нормали.
\end{enumerate}

Для решения поставленной задачи будет использована поверхностная модель. Этот выбор
обусловлен тем, что каркасные модели будут приводить к неправильному восприятию форм объекта,
а объемные не подходят, так как нам не важно из какого материала сделаны объекты сцены.

\section{Выбор способа задания поверхностных моделей}

Существует несколько способов задания поверхностных моделей:
\begin{itemize}
    \item \textit{\textbf{Аналитический способ}}. Данный способ задания модели характеризуется описанием модели
    объекта, которое доступно в неявной форме. То есть для получения поверхности необходимо
    вычислять функцию, зависящую от параметра;
    \item \textit{\textbf{Полигональная сетка}}. Данный способ предстваляет собой совокупность вершин, ребер и полигонов, 
    соединенных таким образом, что каждое ребро принадлежит не более, чем двум многоугольникам. Ребра ограничиваются двумя
    вершинами, а полигоны замыкаются цепочкой из последовательно соединенных ребер~\cite{mgtu}.
\end{itemize}

Из двух способов задания поверхностных моделей наиболее оптимальным является
использование полигональной сетки, так как данный вариант позволяет более быстро выполнять
операции над объектами.

\section{Выбор способа хранения полигональных моделей}

Существует несколько способов хранения полигональных моделей:
\begin{itemize}
    \item \textit{\textbf{Вершинное представление}}. Хранится информация о вершинах, указывающих на другие
    вершины, которые с ними соединены;
    \item \textit{\textbf{Список граней}}. Объект представляется как множество граней и вершин, любая грань состоит
    из минимум трех вершин;
    \item \textit{\textbf{Таблица углов}}. Обход данной таблицы неявно задает полигоны. Такое представление более
    компактно и более производительно для нахождения полигонов. Но из-за того, что вершины
    присутствуют в описании нескольких углов, операции по их изменению медленны;
    \item \textit{\textbf{Крылатое представление}}. Каждая точка ребра указывает на две вершины, 
    две грани и четыре ребра, которые ее касаются.
\end{itemize}

Способом хранения полигональной сетки выбран список граней, так как это даст явное описание граней. 
Этот способ позволит эффективно преобразовывать модели, так как структура будет включать в себя список вершин.

\section{Алгоритмы удаления невидимых линий и поверхностей}

Задача удаления невидимых линий и поверхностей является одной из наиболее сложных в
машинной графике. Алгоритмы удаления невидимых линий и поверхностей служат для
определения ребер, поверхностей или объемов, которые видимы или невидимы для
наблюдателя, находящегося в заданной точке пространства.

Для оптимальной работы реализуемого программного обеспечения алгоритм должен быть
достаточно быстрым при работе со множеством объектов сцены, чтобы не было долгой загрузки
изображения, мог работать в любом пространстве, так как скорость важнее точности.

\subsection{Алгоритм Робертса}

Данный алгоритм работает в объектном пространстве, решая задачу только с выпуклыми телами.

Алгоритм выполняется в 3 этапа:

\begin{enumerate}
	\item \textbf{Этап подготовки исходных данных} 
	
	\setlength{\parindent}{1.25cm}Для каждого объекта сцены формируется матрица тела $V$. 
    Размерность матрицы -- $4 * n$, где $n$ -- количество граней тела.
	
	Каждый столбец матрицы представляет собой четыре коэффициента уравнения плоскости $ax + by + cz + d = 0$, 
    проходящей через очередную грань.

	Таким образом, матрица тела будет представлена в следующем виде:

	\begin{equation}
		V = \begin{pmatrix}
			a_{1} & a_{2} & \ldots & a_{n}\\
			b_{1} & b_{2} & \ldots & b_{n}\\
			c_{1} & c_{2} & \ldots & c_{n}\\
			d_{1} & d_{2} & \ldots & d_{n}
		\end{pmatrix}.
	\end{equation}

    Для корректного формирования матрицы необходимо осуществить проверку, что любая точка, находящаяся внутри тела, 
    располагается на положительной стороне каждой грани этого тела. При не выполнении условия соответствующий столбец 
    матрицы надо умножить на $-1$.
    
    \clearpage
    \item \textbf{Этап удаление ребер и граней, которые перекрываются самим телом} 
	
    На данном этапе рассматривается вектор взгляда $E = \{0, 0, -1, 0\}$. Для определния невидимых ребер и граней 
    достаточно умножить вектор $E$ на матрицу тела $V$. Отрицательные компоненты полученного вектора 
    будут соответствовать невидимым граням.

	\item \textbf{Этап удаления невидимых ребер, экранируемых другими телами сцены}
	
    На данном этапе происходит сравнение видимых ребер каждого тела с каждым из оставшихся тел для определения того, какая его
    часть или части, если таковые есть, перекрываются этими телами~\cite{tpu}.

\end{enumerate}

\textbf{Особенности:}
\begin{itemize}
    \item математические методы, используемые в алгоритме Робертса просты и точны;
    \item вычислительная трудоемкость растет прямо пропорционально квадрату количества
    объектов сцены;
    \item могут возникнуть трудности на этапе подготовки информации об объектах сцены;
    \item возможность работы только с выпуклыми объектами.
\end{itemize}

\subsection{Алгоритм Варнок}

Алгоритм Варнока основан на разбиении картинной плоскости на части, для каждой из которых 
исходная задача может быть решена достаточно просто.

Поскольку данный алгоритм нацелен на обработку картинки, он работает в пространстве изображения. 
В пространстве изображения рассматривается окно и решается вопрос о том, пусто ли оно, или его содержимое 
достаточно просто для визуализации. Если это не так, то окно разбивается на фрагменты до тех пор, пока содержимое фрагмента
не станет достаточно простым для визуализации или его размер не достигнет требуемого предела разрешения~\cite{tpu}. \\

\textbf{Особенности:}
\begin{itemize}
    \item чем меньше часть изображения содержит ифнормации, тем меньше затраты по времени и наоборот;
    \item алгоритм работает рекурсивно.
\end{itemize}

\subsection{Алгоритм обратной трассировкии лучей}

Алгоритм обратной трассировкии лучей работает в пространстве изображения. 
Наблюдатель видит объект посредством испускаемого источником света, который падает 
на этот объект и согласно законам оптики некоторым путем доходит до глаз
наблюдателя.


\textbf{Данный алгоритм состоит из следующих этапов:}
\begin{enumerate}
    \item для каждого пиксела на дисплее проводится прямой луч от наблюдателя до элемента сцены;
    \item пересечение используется для определения цвета пиксела как функции пересекаемой
    поверхности элемента;
    \item проводятся вторичные лучи от точек пересечения до разных
    источников света для определения освещённости пиксела;
    \item если луч блокируется, то точка находится в тени, которую отбрасывает рассматриваемый источник света, иначе
    источник света влияет на освещение.
\end{enumerate}

Для более реалистичного изображения необходимо проводить лучи отражения и лучи преломления.\\

\clearpage
\textbf{Особенности:}
\begin{itemize}
    \item реалистичное изображение объекта, построенное по физическим законам;
    \item большая трудоемксоть вычислений.
\end{itemize}

\subsection{Алгоритм, использующий z-буфер}

Идея z-буфера является простым обобщением идеи о буфере кадра. 
Буфер кадра используется для запоминания атрибутов (интенсивности) каждого пикселя в пространстве изображения, z-буфер ---
это отдельный буфер глубины, используемый для запоминания кооринаты z или
глубины каждого видимого пикселя в пространстве изображения. \\

\textbf{Процесс работы алгоритма, использующего z-буфер:}

\begin{enumerate}
    \item всем элементам буфера кадра присвоить фоновое значение;
    \item инициализировать z-буфер минимальным знчаением глубины;
    \item глубина z каждого нового пикселя, который нужно занести в буфер кадра, сравнивается с глубиной того пикселя,
    который уже занесен в z-буфер;
    \item если сравнение показывает, что новый пиксель расположен впереди пикселя,
    находящегося в буфере кадра, то новый пиксель заносится в этот буфер;
    \item если же сравнение дает противположный результат, то никаких действий не производится.
\end{enumerate}

По сути, алгоритм является поиском по х и у наибольшего значения функции Z(х, у)~\cite{tpu}.\\

\textbf{Особенности:}
\begin{itemize}
    \item простая реализация;
    \item возможность модификации алгоритма для работы с тенями;
    \item работа с любой сложностью поверхостей;
    \item большой объем треубемой памяти для хранения буфера.
\end{itemize}

\subsection{Выбор алгоритма удаления невидимых линий и поверхностей}

Самым подходящим алгоритмом для удаления невидимых линий и поверхносетй будет z-буфер. Выбор обусловлен тем, что данный алгоритм прост в реализации,
работает с любой сложностью сцен, оценка вычислительной трудоемкости алгоритма не более чем линейна.

\section{Выбор алгоритма построения теней}

При выборе алгоритма создания теней важно учесть простоту реализации и время, необходимое для написания алгоритма. 
Если использовать алгоритм обратной трассировки лучей для удаления невидимых ребер и поверхностей, то тени будут автоматически 
созданы в ходе выполнения алгоритма. Это происходит потому, что пиксель затемняется, когда луч, испускаемый из данной точки, 
сталкивается с объектом, но не достигает источника света.

Однако, учитывая сложность алгоритма обратной трассировки, возможно решение модифицировать алгоритм z-буфера, добавив в него 
функцию вычисления теневого буфера.

Такая модификация позволит избежать необходимости написания большого объема дополнительного кода. Вместо этого, 
потребуется лишь внести небольшие изменения в уже использующийся алгоритм.

\section*{Вывод}
Были рассмотрены способы задания и хранения трехмерных моделей, а также выбраны наиболее подходящие из них.
Также были рассмотрены алгоритмы удаления невидимых ребер:
\begin{itemize}
    \item алгоритм Робертса;
    \item алгоритм Варнока;
    \item алгоритм обратной трассировки лучей;
    \item алгоритм, использующий Z-буфер.
\end{itemize}

В качестве реализуемого был выбран алгоритм z-буфера, отвечающего главному требованию --- быстрая работа со множеством объектов сцены. 
Были рассмотрены алгоритмы построения теней. В качестве реализуемого был выбран алгоритм, использующий теневые карты, в работе которого 
будет использоваться z-буфер.

% \section{Описание трехмерных преобразований}

% \subsection{Способы хранения декартовых координат}
% Координаты можно хранить в виде вектор-столбца [x, y, z]. Однако, в таком случае
% неудобно выполнять поворот, так как такой вектор нельзя умножить на квадратные матрицы
% трансформации (размерность 4x4). Можно использовать дополнительную координату w = 1, тогда
% получится вектор-столбец --- [x, y, z, w].

% \subsection{Преобразование трехмерного пространства в двумерное пространство
% экрана}
% Трехмерное пространство описывается тремя единичными ортогональными векторами, а
% пространство экрана описывается только двумя размерностями, шириной и высотой.

% Экран компьютера состоит из пикселей, изменяя цвет которых получается изображение.
% Каждый пиксель задается координатами x и y, поэтому возникают проблемы с сохранением эффекта
% объемности трехмерного объекта на экране компьютера.

% \textbf{Данная проблема решается путем применения четырех преобразований:}
% \begin{enumerate}
%     \item перевод объекта из собственного пространства в мировое;
%     \item перевод объекта из мирового пространства в пространство камеры;
%     \item проекция всех точек из пространства камеры во все видимые точки, где координаты x, y
%     находятся в диапазоне [-w;w], в диапазоне [0;w];
%     \item масштабирование точек, полученных после предыдущего преобразования на картинку
% необходимого разрешения.
% \end{enumerate}

% Для перевода объекта из собственного пространства в пространство экрана компьютера
% используют матрицы преобразования.

% \textbf{Данный роцесс выглядит следующим образом:}
% \begin{enumerate}
%     \item вычисляются все необходимые матрицы;
%     \item вычисленные матрицы перемножаются;
%     \item вектор-строка, описывающая положение точки в пространстве, умножается на итоговую
%     матрицу.
% \end{enumerate}

% \subsection{Преобразование трехмерной сцены в пространство камеры}
% Для того, чтобы преобразовать сцену в пространство камеры нужно умножить каждую
% вершину всех полигональных моделей на матрицу камеры. Сама камера задается набором
% следующих атрибутов: положение центра камеры в мировом пространстве, вектора направления
% взгляда, направления верха камеры.

% \begin{equation}
% 	\begin{pmatrix}
% 		Right & Up & Look & 0 \\
% 		Right & Up & Look & 0 \\
% 		Right & Up & Look & 0 \\
% 		-(Position * Right) & -(Position * Up) & -(Position * Look) & 1
% 	\end{pmatrix}
% \end{equation}

% \begin{itemize}
%     \item \textbf{Look} --- координаты точки в пространстве, на которую смотрит камера;
%     \item \textbf{Up} --- вектор, который указывает куда смотрит верх камеры;
%     \item \textbf{Right} --- ортогональный вектор к вектора направления взгляда и вектору напралвения верха камеры. 
% \end{itemize}






%TODO: пространство камеры







% \subsection{Преобразования трехмерной сцены в пространство области изображения}

% Для того, чтобы преобразовать спроецированные координаты в координаты области
% изображения, достаточно умножить вектор координат на следующую матрицу:

% \begin{equation}
% 	\begin{pmatrix}
% 		hW & 0 & 0 & hW \\
% 		0 & hH & 0 & hH \\
% 		0 & 0 & 1 & 0 \\
% 		0 & 0 & 0 & 1
% 	\end{pmatrix}
% \end{equation}

% \begin{itemize}
%     \item \textbf{W} --- ширина изображения;
%     \item \textbf{H} --- высота изображения;
%     \item \textbf{hW} --- половина ширины изображения;
%     \item \textbf{hH} --- половина высоты изображения.
% \end{itemize}

